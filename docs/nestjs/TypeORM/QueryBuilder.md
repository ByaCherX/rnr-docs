<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">
<link rel="stylesheet" href="../../source.css">

<h1 style="text-align:center">TypeORM - QueryBuilder</h1>

## What is QueryBuilder
QueryBuilder is one of the most powerful features of TypeORM - it allows you to build SQL queries using elegant and convenient syntax, execute them and get automatically transformed entities.

Simple example of QueryBuilder:
```ts
const firstUser = await dataSource
    .getRepository(User)
    .createQueryBuilder("user")
    .where("user.id = :id", { id: 1 })
    .getOne()
```
It builds the following SQL query:
```sql
SELECT
    user.id as userId,
    user.firstName as userFirstName,
    user.lastName as userLastName
FROM users user
WHERE user.id = 1
```

and returns you an instance of ``User``:
```ts
User {
    id: 1,
    firstName: "Timber",
    lastName: "Saw"
}
```

## How to create and use a QueryBuilder
There are several ways how you can create a Query Builder:

* Using DataSource:
```ts
const user = await dataSource
    .createQueryBuilder()
    .select("user")
    .from(User, "user")
    .where("user.id = :id", { id: 1 })
    .getOne()
```

* Using entity manager:
```ts
const user = await dataSource.manager
    .createQueryBuilder(User, "user")
    .where("user.id = :id", { id: 1 })
    .getOne()
```

* Using repository:
```ts
const user = await dataSource
    .getRepository(User)
    .createQueryBuilder("user")
    .where("user.id = :id", { id: 1 })
    .getOne()
```

## Getting values using QueryBuilder
To get a single result from the database, for example to get a user by id or name, you must use ``getOne``:

```ts
const timber = await dataSource
    .getRepository(User)
    .createQueryBuilder("user")
    .where("user.id = :id OR user.name = :name", { id: 1, name: "Timber" })
    .getOne()
```

## Adding WHERE expression
Adding a WHERE expression is as easy as:
```ts
createQueryBuilder("user").where("user.name = :name", { name: "Timber" })
```

Which will produce:
```sql
SELECT ... FROM users user WHERE user.name = 'Timber'
```

You can do an IN query with the WHERE expression:
```ts
createQueryBuilder("user").where("user.id IN (:...ids)", { ids: [1, 2, 3, 4] })
```

## Adding HAVING expression
Adding a ``HAVING`` expression is easy as:
```ts
createQueryBuilder("user").having("user.name = :name", { name: "Timber" })
```

Which will produce following SQL query:
```sql
SELECT ... FROM users user HAVING user.name = 'Timber'
```

## Adding ORDER BY expression
Adding an ``ORDER BY`` expression is easy as:`
```ts
createQueryBuilder("user").orderBy("user.id")
//SQL=> SELECT ... FROM users user ORDER BY user.id
```

## Adding LIMIT expression
Adding a LIMIT expression is easy as:
```ts
createQueryBuilder("user").limit(10)
```

## Joining relations 
Now let's say you want to load user "Timber" with all of his photos:
```ts
const user = await createQueryBuilder("user")
    .leftJoinAndSelect("user.photos", "photo")
    .where("user.name = :name", { name: "Timber" })
    .getOne()

/* get the result:
{
    id: 1,
    name: "Timber",
    photos: [{
        id: 1,
        url: "me-with-chakram.jpg"
    }, {
        id: 2,
        url: "me-with-trees.jpg"
    }]
}
*/
```

This will generate following SQL query:
```sql
SELECT user.*, photo.* FROM users user
    LEFT JOIN photos photo ON photo.user = user.id
    WHERE user.name = 'Timber' AND photo.isRemoved = FALSE
```

## Inner and left joins
If you want to use INNER JOIN instead of LEFT JOIN just use innerJoinAndSelect instead:
```ts
const user = await createQueryBuilder("user")
    .innerJoinAndSelect(
        "user.photos",
        "photo",
        "photo.isRemoved = :isRemoved",
        { isRemoved: false },
    )
    .where("user.name = :name", { name: "Timber" })
    .getOne()
```
The difference between ``LEFT JOIN`` and ``INNER JOIN`` is that INNER JOIN won't return a user if it does not have any photos. LEFT JOIN will return you the user even if it doesn't have photos. To learn more about different join types, refer to the SQL documentation.

## Joining any entity or table
You can join not only relations, but also other unrelated entities or tables. Examples:
```ts
const user = await createQueryBuilder("user")
    .leftJoinAndSelect(Photo, "photo", "photo.userId = user.id")
    .getMany()
```
```ts
const user = await createQueryBuilder("user")
    .leftJoinAndSelect("photos", "photo", "photo.userId = user.id")
    .getMany()
```

## Getting the generated query
Sometimes you may want to get the SQL query generated by QueryBuilder. To do so, use getSql:
```ts
const sql = createQueryBuilder("user")
    .where("user.firstName = :firstName", { firstName: "Timber" })
    .orWhere("user.lastName = :lastName", { lastName: "Saw" })
    .getSql()
```

## Getting raw results
There are two types of results you can get using select query builder: entities and raw results. Most of the time, you need to select real entities from your database, for example, users. For this purpose, you use getOne and getMany. However, sometimes you need to select specific data, like the sum of all user photos. Such data is not a entity, it's called raw data. To get raw data, you use getRawOne and getRawMany. Examples:
```ts
const { sum } = await dataSource
    .getRepository(User)
    .createQueryBuilder("user")
    .select("SUM(user.photosCount)", "sum")
    .where("user.id = :id", { id: 1 })
    .getRawOne()
```

## Partial selection
If you want to select only some entity properties, you can use the following syntax:
```ts
const users = await dataSource
    .getRepository(User)
    .createQueryBuilder("user")
    .select(["user.id", "user.name"])
    .getMany()
```


<h1 class="h1color">Insert/Update/Delete using Query Builder</h1>

## Insert using Query Builder

You can create ``INSERT`` queries using QueryBuilder. Examples:
```ts
await dataSource
    .createQueryBuilder()
    .insert()
    .into(User)
    .values([
        { firstName: "Timber", lastName: "Saw" },
        { firstName: "Phantom", lastName: "Lancer" },
    ])
    .execute()
```
This is the most efficient way in terms of performance to insert rows into your database. You can also perform bulk insertions this way.

In some cases when you need to execute SQL queries you need to use function style value:
```ts
await dataSource
    .createQueryBuilder()
    .insert()
    .into(User)
    .values({
        firstName: "Timber",
        lastName: () => "CONCAT('S', 'A', 'W')",
    })
    .execute()
```

## Update using Query Builder
You can create UPDATE queries using QueryBuilder. Examples:
```ts
await dataSource
    .createQueryBuilder()
    .update(User)
    .set({ firstName: "Timber", lastName: "Saw" })
    .where("id = :id", { id: 1 })
    .execute()
```
This is the most efficient way in terms of performance to update entities in your database.

In some cases when you need to execute SQL queries you need to use function style value:
```ts
await dataSource
    .createQueryBuilder()
    .update(User)
    .set({
        firstName: "Timber",
        lastName: "Saw",
        age: () => "age + 1",
    })
    .where("id = :id", { id: 1 })
    .execute()
```

## Delete using Query Builder
You can create DELETE queries using QueryBuilder. Examples:
```ts
await myDataSource
    .createQueryBuilder()
    .delete()
    .from(User)
    .where("id = :id", { id: 1 })
    .execute()
```

Applying Soft Delete to QueryBuilder
```ts
await dataSource.getRepository(Entity).createQueryBuilder().softDelete()
```

Alternatively, You can recover the soft deleted rows by using the restore() method:
```ts
await dataSource.getRepository(Entity).createQueryBuilder().restore()
```


<h1 class="h1color">Working with Relations</h1>
RelationQueryBuilder is a special type of QueryBuilder which allows you to work with your relations. Using it, you can bind entities to each other in the database without the need to load any entities, or you can load related entities easily.

For example, we have a Post entity and it has a many-to-many relation to Category called categories. Let's add a new category to this many-to-many relation:
```ts
await dataSource
    .createQueryBuilder()
    .relation(Post, "categories")
    .of(post)
    .add(category)
```

This code is equivalent to doing this:
```ts
const postRepository = dataSource.manager.getRepository(Post)
const post = await postRepository.findOne({
    where: {
        id: 1,
    },
    relations: {
        categories: true,
    },
})
post.categories.push(category)
await postRepository.save(post)
```
But more efficient, because it does a minimal number of operations, and binds entities in the database, unlike calling a bulky save method call.


Besides updating relations, the relational query builder also allows you to load relational entities. For example, lets say inside a Post entity we have a many-to-many categories relation and a many-to-one user relation, to load those relations you can use following code:
```ts
const post = await dataSource.manager.findOneBy(Post, {
    id: 1,
})

post.categories = await dataSource
    .createQueryBuilder()
    .relation(Post, "categories")
    .of(post) // you can use just post id as well
    .loadMany()

post.author = await dataSource
    .createQueryBuilder()
    .relation(Post, "user")
    .of(post) // you can use just post id as well
    .loadOne()
```





